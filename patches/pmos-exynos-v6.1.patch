this is the diff between mainline v6.1 and https://gitlab.com/exynos5-mainline/linux/
as of commit 57c720c971830607f7b21cab6dab534a353a3177 and it was created by doing the
following steps in checked out mainline v6.1 tree:

git clone https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-stable-cbe
cd linux-stable-cbe
git checkout v6.1
git remote add pmos-exynos https://gitlab.com/exynos5-mainline/linux.git/
git remote update
git diff v6.1 remotes/pmos-exynos/master
git remote rm pmos-exynos

afterwards two meson patches not belonging here were removed (most probably they were for a
meson s805 based odroid c1)

diff --git a/Documentation/devicetree/bindings/arm/samsung/samsung-boards.yaml b/Documentation/devicetree/bindings/arm/samsung/samsung-boards.yaml
index faea33e4f731..b4113621d1cb 100644
--- a/Documentation/devicetree/bindings/arm/samsung/samsung-boards.yaml
+++ b/Documentation/devicetree/bindings/arm/samsung/samsung-boards.yaml
@@ -142,6 +142,7 @@ properties:
               - insignal,arndale-octa           # Insignal Arndale Octa
               - samsung,chagall-wifi            # Samsung SM-T800
               - samsung,klimt-wifi              # Samsung SM-T700
+              - samsung,klimt-lte               # Samsung SM-T705
               - samsung,smdk5420                # Samsung SMDK5420 eval
           - const: samsung,exynos5420
           - const: samsung,exynos5
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 9f406e9c0ea6..750c8c0d5d9e 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -892,6 +892,8 @@ __armv7_mmu_cache_on:
 		bic     r6, r6, #1 << 31        @ 32-bit translation system
 		bic     r6, r6, #(7 << 0) | (1 << 4)	@ use only ttbr0
 		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
+		mcrne	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
+		mcr	p15, 0, r0, c7, c5, 4	@ ISB
 		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
 		mcrne   p15, 0, r6, c2, c0, 2   @ load ttb control
 #endif
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 6aa7dc4db2fc..def16a9a7ee2 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -239,6 +239,7 @@ dtb-$(CONFIG_ARCH_EXYNOS5) += \
 	exynos5420-peach-pit.dtb \
 	exynos5420-smdk5420.dtb \
 	exynos5420-chagall-wifi.dtb \
+	exynos5420-klimt-lte.dtb \
 	exynos5420-klimt-wifi.dtb \
 	exynos5422-odroidhc1.dtb \
 	exynos5422-odroidxu3.dtb \
diff --git a/arch/arm/boot/dts/exynos5250-snow-common.dtsi b/arch/arm/boot/dts/exynos5250-snow-common.dtsi
index 3d84b9c6dea3..22632988860b 100644
--- a/arch/arm/boot/dts/exynos5250-snow-common.dtsi
+++ b/arch/arm/boot/dts/exynos5250-snow-common.dtsi
@@ -15,6 +15,10 @@
 / {
 	aliases {
 		i2c104 = &i2c_104;
+
+		mmc0 = &mmc_0; /* eMMC */
+		mmc1 = &mmc_2; /* SD */
+		mmc2 = &mmc_3; /* WiFi */
 	};
 
 	memory@40000000 {
@@ -77,6 +81,22 @@ i2c_104: i2c@0 {
 			#address-cells = <1>;
 			#size-cells = <0>;
 
+			usb-hub@8 {
+				compatible = "smsc,usb3503a";
+				reg = <0x08>;
+
+				reset-gpios = <&gpe1 0 GPIO_ACTIVE_LOW>;
+				disabled-ports = <3>;
+				initial-mode = <1>;
+
+				clock-names = "refclk";
+				clocks = <&pmu_system_controller 0>;
+				refclk-frequency = <24000000>;
+
+				pinctrl-names = "default";
+				pinctrl-0 = <&usb_hub_reset>;
+			};
+
 			battery: sbs-battery@b {
 				compatible = "sbs,sbs-battery";
 				reg = <0xb>;
@@ -174,6 +194,11 @@ charger {
 
 	sound {
 		samsung,i2s-controller = <&i2s0>;
+		samsung,hp-det-gpios = <&gpx2 2 GPIO_ACTIVE_HIGH>;
+		samsung,mic-det-gpios = <&gpx2 0 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det_gpio &mic_det_gpio>;
 	};
 
 	usb3_vbus_reg: regulator-usb3 {
@@ -197,8 +222,9 @@ xxti {
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pwm 0 1000000 0>;
-		brightness-levels = <0 100 500 1000 1500 2000 2500 2800>;
-		default-brightness-level = <7>;
+		brightness-levels = <1 255>;
+		num-interpolated-steps = <254>;
+		default-brightness-level = <254>;
 		enable-gpios = <&gpx3 0 GPIO_ACTIVE_HIGH>;
 		power-supply = <&fet1>;
 		pinctrl-0 = <&pwm0_out>;
@@ -446,6 +472,21 @@ trackpad@67 {
 		interrupt-parent = <&gpx1>;
 		wakeup-source;
 	};
+
+	/* Atmel mXT which is used in some revisions */
+	trackpad@4b {
+		compatible = "atmel,maxtouch";
+		reg = <0x4b>;
+		interrupt-parent = <&gpx1>;
+		interrupts = <2 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-source;
+		linux,gpio-keymap = <KEY_RESERVED
+				     KEY_RESERVED
+				     KEY_RESERVED	/* GPIO0 */
+				     KEY_RESERVED	/* GPIO1 */
+				     KEY_RESERVED	/* GPIO2 */
+				     BTN_LEFT>;		/* GPIO3 */
+	};
 };
 
 /*
@@ -615,6 +656,20 @@ ec_irq: ec-irq-pins {
 		samsung,pin-drv = <EXYNOS4_PIN_DRV_LV1>;
 	};
 
+	mic_det_gpio: mic-det-gpio-pins {
+		samsung,pins = "gpx2-0";
+		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
+		samsung,pin-pud = <EXYNOS_PIN_PULL_NONE>;
+		samsung,pin-drv = <EXYNOS4_PIN_DRV_LV1>;
+	};
+
+	hp_det_gpio: hp-det-gpio-pins {
+		samsung,pins = "gpx2-2";
+		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
+		samsung,pin-pud = <EXYNOS_PIN_PULL_DOWN>;
+		samsung,pin-drv = <EXYNOS4_PIN_DRV_LV1>;
+	};
+
 	tps65090_irq: tps65090-irq-pins {
 		samsung,pins = "gpx2-6";
 		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
@@ -665,6 +720,13 @@ arb_our_claim: arb-our-claim-pins {
 		samsung,pin-pud = <EXYNOS_PIN_PULL_NONE>;
 		samsung,pin-drv = <EXYNOS4_PIN_DRV_LV1>;
 	};
+
+	usb_hub_reset: usb-hub-reset-pins {
+		samsung,pins = "gpe1-0";
+		samsung,pin-function = <EXYNOS_PIN_FUNC_OUTPUT>;
+		samsung,pin-pud = <EXYNOS_PIN_PULL_NONE>;
+		samsung,pin-drv = <EXYNOS4_PIN_DRV_LV1>;
+	};
 };
 
 &pmu_system_controller {
diff --git a/arch/arm/boot/dts/exynos5250-snow-rev5.dts b/arch/arm/boot/dts/exynos5250-snow-rev5.dts
index 0a47597d6f0d..74f6d45885ad 100644
--- a/arch/arm/boot/dts/exynos5250-snow-rev5.dts
+++ b/arch/arm/boot/dts/exynos5250-snow-rev5.dts
@@ -27,7 +27,7 @@ cpu {
 		};
 
 		codec {
-			sound-dai = <&max98090 0>, <&hdmi>;
+			sound-dai = <&max98090 0>;
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/exynos5250-snow.dts b/arch/arm/boot/dts/exynos5250-snow.dts
index 906aa7aae710..4c2c3e9f1467 100644
--- a/arch/arm/boot/dts/exynos5250-snow.dts
+++ b/arch/arm/boot/dts/exynos5250-snow.dts
@@ -25,7 +25,7 @@ cpu {
 		};
 
 		codec {
-			sound-dai = <&max98095 0>, <&hdmi>;
+			sound-dai = <&max98095 0>;
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/exynos5420-klimt-lte.dts b/arch/arm/boot/dts/exynos5420-klimt-lte.dts
new file mode 100644
index 000000000000..2a9af1f18de7
--- /dev/null
+++ b/arch/arm/boot/dts/exynos5420-klimt-lte.dts
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Samsung's Exynos5420 Klimt LTE board device tree source
+ *
+ * Copyright (c) 2012-2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ * Copyright (c) 2022 Henrik Grimler
+ */
+
+/dts-v1/;
+#include "exynos5420-galaxy-tab-common.dtsi"
+
+/ {
+	model = "Samsung Klimt LTE based on Exynos5420";
+	compatible = "samsung,klimt-lte", "samsung,exynos5420", \
+		     "samsung,exynos5";
+};
+
+&ldo15_reg {
+	regulator-name = "VDD_LEDA_2V8";
+	regulator-min-microvolt = <2800000>;
+	regulator-max-microvolt = <2800000>;
+
+	regulator-state-mem {
+		regulator-on-in-suspend;
+	};
+};
+
+&ldo17_reg {
+	regulator-name = "VDD_VCI_3V0";
+	regulator-min-microvolt = <3000000>;
+	regulator-max-microvolt = <3000000>;
+
+	regulator-state-mem {
+		regulator-off-in-suspend;
+	};
+};
+
+&ldo28_reg {
+	regulator-name = "VDD3_1V8";
+	regulator-min-microvolt = <1800000>;
+	regulator-max-microvolt = <1800000>;
+
+	regulator-state-mem {
+		regulator-off-in-suspend;
+	};
+};
+
+&ldo29_reg {
+	regulator-name = "VDDR_1V6";
+	regulator-min-microvolt = <1600000>;
+	regulator-max-microvolt = <1600000>;
+
+	regulator-state-mem {
+		regulator-off-in-suspend;
+	};
+};
+
+&ldo31_reg {
+	regulator-name = "VDD_GRIP_1V8";
+	regulator-min-microvolt = <1800000>;
+	regulator-max-microvolt = <1800000>;
+	regulator-always-on;
+	regulator-boot-on;
+
+	regulator-state-mem {
+		regulator-off-in-suspend;
+	};
+};
+
+&ldo32_reg {
+	regulator-name = "VDD_TSP_1V8";
+	regulator-min-microvolt = <1800000>;
+	regulator-max-microvolt = <1800000>;
+
+	regulator-state-mem {
+		regulator-off-in-suspend;
+	};
+};
+
+&mmc_2 {
+	sd-uhs-sdr104;
+};
diff --git a/arch/arm/boot/dts/exynos5420-peach-pit.dts b/arch/arm/boot/dts/exynos5420-peach-pit.dts
index 9e2123470cad..188c4d482fb9 100644
--- a/arch/arm/boot/dts/exynos5420-peach-pit.dts
+++ b/arch/arm/boot/dts/exynos5420-peach-pit.dts
@@ -31,13 +31,18 @@ / {
 	aliases {
 		/* Assign 20 so we don't get confused w/ builtin ones */
 		i2c20 = &i2c_tunnel;
+
+		mmc0 = &mmc_0; /* eMMC */
+		mmc1 = &mmc_2; /* uSD */
+		mmc2 = &mmc_1; /* WiFi */
 	};
 
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pwm 0 1000000 0>;
-		brightness-levels = <0 100 500 1000 1500 2000 2500 2800>;
-		default-brightness-level = <7>;
+		brightness-levels = <1 255>;
+		num-interpolated-steps = <254>;
+		default-brightness-level = <254>;
 		power-supply = <&tps65090_fet1>;
 		pinctrl-0 = <&pwm0_out>;
 		pinctrl-names = "default";
@@ -88,13 +93,18 @@ sound {
 		samsung,model = "Peach-Pit-I2S-MAX98090";
 		samsung,i2s-controller = <&i2s0>;
 		samsung,audio-codec = <&max98090>;
+		samsung,hp-det-gpios = <&gpx2 1 GPIO_ACTIVE_HIGH>;
+		samsung,mic-det-gpios = <&gpx1 7 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det_gpio &mic_det_gpio>;
 
 		cpu {
 			sound-dai = <&i2s0 0>;
 		};
 
 		codec {
-			sound-dai = <&max98090>, <&hdmi>;
+			sound-dai = <&max98090>;
 		};
 	};
 
@@ -189,6 +199,11 @@ &fimd {
 	samsung,invert-vclk;
 };
 
+&gpu {
+	status = "okay";
+	mali-supply = <&buck4_reg>;
+};
+
 &hdmi {
 	status = "okay";
 	hpd-gpios = <&gpx3 7 GPIO_ACTIVE_HIGH>;
@@ -825,6 +840,20 @@ ec_irq: ec-irq-pins {
 		samsung,pin-drv = <EXYNOS5420_PIN_DRV_LV1>;
 	};
 
+	mic_det_gpio: mic-det-gpio-pins {
+		samsung,pins = "gpx1-7";
+		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
+		samsung,pin-pud = <EXYNOS_PIN_PULL_NONE>;
+		samsung,pin-drv = <EXYNOS5420_PIN_DRV_LV1>;
+	};
+
+	hp_det_gpio: hp-det-gpio-pins {
+		samsung,pins = "gpx2-1";
+		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
+		samsung,pin-pud = <EXYNOS_PIN_PULL_NONE>;
+		samsung,pin-drv = <EXYNOS5420_PIN_DRV_LV1>;
+	};
+
 	tps65090_irq: tps65090-irq-pins {
 		samsung,pins = "gpx2-5";
 		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
diff --git a/arch/arm/boot/dts/exynos5800-peach-pi.dts b/arch/arm/boot/dts/exynos5800-peach-pi.dts
index 0ebcb66c6319..2c5e879bead3 100644
--- a/arch/arm/boot/dts/exynos5800-peach-pi.dts
+++ b/arch/arm/boot/dts/exynos5800-peach-pi.dts
@@ -29,13 +29,18 @@ / {
 	aliases {
 		/* Assign 20 so we don't get confused w/ builtin ones */
 		i2c20 = &i2c_tunnel;
+
+		mmc0 = &mmc_0; /* eMMC */
+		mmc1 = &mmc_2; /* SD */
+		mmc2 = &mmc_1; /* WiFi */
 	};
 
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pwm 0 1000000 0>;
-		brightness-levels = <0 100 500 1000 1500 2000 2500 2800>;
-		default-brightness-level = <7>;
+		brightness-levels = <1 255>;
+		num-interpolated-steps = <254>;
+		default-brightness-level = <254>;
 		enable-gpios = <&gpx2 2 GPIO_ACTIVE_HIGH>;
 		power-supply = <&tps65090_fet1>;
 		pinctrl-0 = <&pwm0_out>;
@@ -88,13 +93,18 @@ sound {
 		samsung,model = "Peach-Pi-I2S-MAX98091";
 		samsung,i2s-controller = <&i2s0>;
 		samsung,audio-codec = <&max98091>;
+		samsung,hp-det-gpios = <&gpx2 1 GPIO_ACTIVE_HIGH>;
+		samsung,mic-det-gpios = <&gpx1 7 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det_gpio &mic_det_gpio>;
 
 		cpu {
 			sound-dai = <&i2s0 0>;
 		};
 
 		codec {
-			sound-dai = <&max98091>, <&hdmi>;
+			sound-dai = <&max98091>;
 		};
 	};
 
@@ -198,6 +208,11 @@ &fimd {
 	samsung,invert-vclk;
 };
 
+&gpu {
+	status = "okay";
+	mali-supply = <&buck4_reg>;
+};
+
 &hdmi {
 	status = "okay";
 	hpd-gpios = <&gpx3 7 GPIO_ACTIVE_HIGH>;
@@ -807,6 +822,20 @@ ec_irq: ec-irq-pins {
 		samsung,pin-drv = <EXYNOS5420_PIN_DRV_LV1>;
 	};
 
+	mic_det_gpio: mic-det-gpio-pins {
+		samsung,pins = "gpx1-7";
+		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
+		samsung,pin-pud = <EXYNOS_PIN_PULL_NONE>;
+		samsung,pin-drv = <EXYNOS5420_PIN_DRV_LV1>;
+	};
+
+	hp_det_gpio: hp-det-gpio-pins {
+		samsung,pins = "gpx2-1";
+		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
+		samsung,pin-pud = <EXYNOS_PIN_PULL_NONE>;
+		samsung,pin-drv = <EXYNOS5420_PIN_DRV_LV1>;
+	};
+
 	tps65090_irq: tps65090-irq-pins {
 		samsung,pins = "gpx2-5";
 		samsung,pin-function = <EXYNOS_PIN_FUNC_INPUT>;
diff --git a/arch/arm/mach-exynos/exynos.c b/arch/arm/mach-exynos/exynos.c
index 51a247ca4da8..172d418cbfb4 100644
--- a/arch/arm/mach-exynos/exynos.c
+++ b/arch/arm/mach-exynos/exynos.c
@@ -221,3 +221,31 @@ DT_MACHINE_START(EXYNOS_DT, "Samsung Exynos (Flattened Device Tree)")
 	.dt_compat	= exynos_dt_compat,
 	.dt_fixup	= exynos_dt_fixup,
 MACHINE_END
+
+#define ODROID_MACHINE_START(name, compat)			\
+	DT_MACHINE_START(EXYNOS5422_ODROID_##name, "ODROID-"#name)	\
+		.l2c_aux_val	= 0x3c400001,			\
+		.l2c_aux_mask	= 0xc20fffff,			\
+		.smp		= smp_ops(exynos_smp_ops),	\
+		.map_io		= exynos_init_io,		\
+		.init_early	= exynos_firmware_init,		\
+		.init_irq	= exynos_init_irq,		\
+		.init_machine	= exynos_dt_machine_init,	\
+		.init_late	= exynos_pm_init,		\
+		.dt_compat	= compat,			\
+		.dt_fixup	= exynos_dt_fixup,		\
+	MACHINE_END
+
+static char const *const exynos5422_odroidxu3_dt_compat[] __initconst = {
+	"hardkernel,odroid-xu3",
+	"hardkernel,odroid-xu3-lite",
+	NULL,
+};
+
+static char const *const exynos5422_odroidxu4_dt_compat[] __initconst = {
+	"hardkernel,odroid-xu4",
+	NULL,
+};
+
+ODROID_MACHINE_START(XU3, exynos5422_odroidxu3_dt_compat)
+ODROID_MACHINE_START(XU4, exynos5422_odroidxu4_dt_compat)
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index d7909091cf97..88314036a021 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -1326,6 +1326,64 @@ static void arm_iommu_unmap_sg(struct device *dev,
 	}
 }
 
+static struct sg_table *arm_iommu_alloc_noncontiguous(struct device *dev,
+		size_t size, enum dma_data_direction dir, gfp_t gfp,
+		unsigned long attrs)
+{
+	struct dma_sgt_handle *sh;
+	int count;
+
+	sh = kmalloc(sizeof(*sh), gfp);
+	if (!sh)
+		return NULL;
+
+	size = PAGE_ALIGN(size);
+	count = size >> PAGE_SHIFT;
+
+	/*
+	 * Following is a work-around (a.k.a. hack) to prevent pages
+	 * with __GFP_COMP being passed to split_page() which cannot
+	 * handle them.  The real problem is that this flag probably
+	 * should be 0 on ARM as it is not supported on this
+	 * platform; see CONFIG_HUGETLBFS.
+	 */
+	gfp &= ~(__GFP_COMP);
+
+	sh->pages = __iommu_alloc_buffer(dev, size, gfp, attrs, false);
+	if (!sh->pages)
+		goto err_sh;
+
+	if (sg_alloc_table_from_pages(&sh->sgt, sh->pages, count, 0, size,
+	    GFP_KERNEL))
+		goto err_buffer;
+
+	/* not coherent */
+	if (arm_iommu_map_sg(dev, sh->sgt.sgl, sh->sgt.orig_nents, dir, attrs) < 1)
+		goto err_free_sg;
+
+	return &sh->sgt;
+
+err_free_sg:
+	sg_free_table(&sh->sgt);
+err_buffer:
+	__iommu_free_buffer(dev, sh->pages, size, attrs);
+err_sh:
+	kfree(sh);
+	return NULL;
+}
+
+static void arm_iommu_free_noncontiguous(struct device *dev, size_t size,
+			struct sg_table *sgt, enum dma_data_direction dir)
+{
+	struct dma_sgt_handle *sh = sgt_handle(sgt);
+
+	/* not coherent */
+	arm_iommu_unmap_sg(dev, sgt->sgl, sgt->orig_nents, dir, 0);
+	__iommu_free_buffer(dev, sh->pages, PAGE_ALIGN(size), 0);
+	sg_free_table(&sh->sgt);
+	kfree(sh);
+}
+
 /**
  * arm_iommu_sync_sg_for_cpu
  * @dev: valid struct device pointer
@@ -1531,6 +1589,8 @@ static const struct dma_map_ops iommu_ops = {
 
 	.map_page		= arm_iommu_map_page,
 	.unmap_page		= arm_iommu_unmap_page,
+	.alloc_noncontiguous    = arm_iommu_alloc_noncontiguous,
+	.free_noncontiguous    = arm_iommu_free_noncontiguous,
 	.sync_single_for_cpu	= arm_iommu_sync_single_for_cpu,
 	.sync_single_for_device	= arm_iommu_sync_single_for_device,
 
diff --git a/drivers/gpu/drm/drm_ioctl.c b/drivers/gpu/drm/drm_ioctl.c
index ca2a6e6101dc..1f5741318eb8 100644
--- a/drivers/gpu/drm/drm_ioctl.c
+++ b/drivers/gpu/drm/drm_ioctl.c
@@ -678,9 +678,9 @@ static const struct drm_ioctl_desc drm_ioctls[] = {
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_RMFB, drm_mode_rmfb_ioctl, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_PAGE_FLIP, drm_mode_page_flip_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DIRTYFB, drm_mode_dirtyfb_ioctl, DRM_MASTER),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, 0),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_MAP_DUMB, drm_mode_mmap_dumb_ioctl, 0),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, 0),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_GETPROPERTIES, drm_mode_obj_get_properties_ioctl, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_SETPROPERTY, drm_mode_obj_set_property_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CURSOR2, drm_mode_cursor2_ioctl, DRM_MASTER),
diff --git a/drivers/gpu/drm/tiny/Kconfig b/drivers/gpu/drm/tiny/Kconfig
index 565957264875..6ea9ee1e42ef 100644
--- a/drivers/gpu/drm/tiny/Kconfig
+++ b/drivers/gpu/drm/tiny/Kconfig
@@ -148,6 +148,19 @@ config TINYDRM_ILI9486
 
 	  If M is selected the module will be called ili9486.
 
+config TINYDRM_ILI9488_PIO
+	tristate "DRM support for ILI9488 display panels (8bit PIO)"
+	depends on DRM
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for th following Ilitek ILI9488 panels:
+          * Hardkernel 3.5" 480x320 TFT (HKTFT 3.5")
+
+	  If M is selected the module will be called hktft35.
+
 config TINYDRM_MI0283QT
 	tristate "DRM support for MI0283QT"
 	depends on DRM && SPI
diff --git a/drivers/gpu/drm/tiny/Makefile b/drivers/gpu/drm/tiny/Makefile
index 1d9d6227e7ab..2d617bb921c7 100644
--- a/drivers/gpu/drm/tiny/Makefile
+++ b/drivers/gpu/drm/tiny/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_TINYDRM_ILI9163)		+= ili9163.o
 obj-$(CONFIG_TINYDRM_ILI9225)		+= ili9225.o
 obj-$(CONFIG_TINYDRM_ILI9341)		+= ili9341.o
 obj-$(CONFIG_TINYDRM_ILI9486)		+= ili9486.o
+obj-$(CONFIG_TINYDRM_ILI9488_PIO)	+= ili9488_pio.o
 obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
 obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
 obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
diff --git a/drivers/gpu/drm/tiny/ili9341.c b/drivers/gpu/drm/tiny/ili9341.c
index 69b265e78096..f91e849a0a75 100644
--- a/drivers/gpu/drm/tiny/ili9341.c
+++ b/drivers/gpu/drm/tiny/ili9341.c
@@ -163,12 +163,14 @@ static const struct drm_driver ili9341_driver = {
 
 static const struct of_device_id ili9341_of_match[] = {
 	{ .compatible = "adafruit,yx240qv29" },
+	{ .compatible = "hardkernel,hktft32" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9341_of_match);
 
 static const struct spi_device_id ili9341_id[] = {
 	{ "yx240qv29", 0 },
+	{ "hktft32", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(spi, ili9341_id);
diff --git a/drivers/gpu/drm/tiny/ili9488_pio.c b/drivers/gpu/drm/tiny/ili9488_pio.c
new file mode 100644
index 000000000000..f3a0b1fb885a
--- /dev/null
+++ b/drivers/gpu/drm/tiny/ili9488_pio.c
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Hardkernel 3.5 ISP TFT display
+ *
+ * Copyright 2021 Dongjin Kim <tobetter@gmail.com>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_managed.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_rect.h>
+
+#define ILI9488_COLUMN_ADDR	0x2a
+#define ILI9488_PAGE_ADDR	0x2b
+#define ILI9488_MEMORY_WRITE	0x2c
+#define ILI9488_ITFCTR1         0xb0
+#define ILI9488_FRMCTR1		0xb1
+#define ILI9488_PWCTRL1         0xc2
+#define ILI9488_VMCTRL1         0xc5
+#define ILI9488_PGAMCTRL        0xe0
+#define ILI9488_NGAMCTRL        0xe1
+#define ILI9488_MADCTL_BGR      BIT(3)
+#define ILI9488_MADCTL_MV       BIT(5)
+#define ILI9488_MADCTL_MX       BIT(6)
+#define ILI9488_MADCTL_MY       BIT(7)
+
+struct ili9488_data {
+	struct mipi_dbi_dev *dbidev;
+	struct gpio_desc *wr;
+	struct gpio_desc *cs;
+	struct gpio_desc *db[8];
+	void __iomem *membase;
+	u32 mask;
+	u32 bits[8];
+	u32 bits_wr;
+};
+
+static struct ili9488_data *pdata;
+static u32 *rgb;
+
+static u32 ili9488_rgb565_to_gpiobus(struct ili9488_data *pdata, u8 color)
+{
+	int i;
+	u32 value = 0;
+
+	for (i = 0; i < 8; i++) {
+		if (color & 1)
+			value |= pdata->bits[i];
+		else
+			value &= ~(pdata->bits[i]);
+		color >>= 1;
+	}
+
+	return value;
+}
+
+static int ili9488_bus_write(struct mipi_dbi *dbi, u8 data)
+{
+	int i;
+
+	if (pdata->membase) {
+		u32 v = (readl(pdata->membase) & ~pdata->mask) | *(rgb + data);
+		writel(v, pdata->membase);
+		writel(v | pdata->bits_wr, pdata->membase);
+		return 0;
+	}
+
+	gpiod_set_value(pdata->wr, 0);
+	for (i = 0; i < 8; i++) {
+		gpiod_set_value(pdata->db[i], data & 1);
+		data >>= 1;
+	}
+	gpiod_set_value(pdata->wr, 1);
+
+	return 0;
+}
+
+static int ili9488_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par, size_t num)
+{
+	u8 *p = par;
+
+	gpiod_set_value(dbi->dc, 0);
+	ili9488_bus_write(dbi, *cmd);
+	gpiod_set_value(dbi->dc, 1);
+
+	while (num--)
+		ili9488_bus_write(dbi, *p++);
+
+	return 0;
+}
+
+static void ili9488_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	gpiod_set_value(pdata->cs, 0);
+
+	mipi_dbi_command(dbi, ILI9488_ITFCTR1, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(250);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+	mipi_dbi_command(dbi, ILI9488_PWCTRL1, 0x33);
+	mipi_dbi_command(dbi, ILI9488_VMCTRL1, 0x00, 0x1e, 0x80, 0x00);
+	mipi_dbi_command(dbi, ILI9488_FRMCTR1, 0xb0, 0x11);
+	mipi_dbi_command(dbi, ILI9488_PGAMCTRL,
+			0x00, 0x04, 0x0e, 0x08, 0x17, 0x0a, 0x40, 0x79,
+			0x4d, 0x07, 0x0e, 0x0a, 0x1a, 0x1d, 0x0f);
+	mipi_dbi_command(dbi, ILI9488_NGAMCTRL,
+			0x00, 0x1b, 0x1f, 0x02, 0x10, 0x05, 0x32, 0x34,
+			0x43, 0x02, 0x0a, 0x09, 0x33, 0x37, 0x0f);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+ out_enable:
+	switch (dbidev->rotation) {
+		case 90:
+			addr_mode = ILI9488_MADCTL_MY;
+			break;
+		case 180:
+			addr_mode = ILI9488_MADCTL_MV;
+			break;
+		case 270:
+			addr_mode = ILI9488_MADCTL_MX;
+			break;
+		default:
+			addr_mode = ILI9488_MADCTL_MV | ILI9488_MADCTL_MY |
+				ILI9488_MADCTL_MX;
+			break;
+	}
+
+	addr_mode |= ILI9488_MADCTL_BGR;
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs ili9488_pipe_funcs = {
+	.enable = ili9488_pipe_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode ili9488_mode = {
+	DRM_SIMPLE_MODE(480, 320, 73, 49),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(ili9488_fops);
+
+static struct drm_driver ili9488_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &ili9488_fops,
+	DRM_GEM_CMA_DRIVER_OPS_VMAP,
+	.name			= "ili9488",
+	.desc			= "Ilitek ILI9488",
+	.date			= "20210201",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int ili9488_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct mipi_dbi *dbi;
+	struct drm_device *drm;
+	struct mipi_dbi_dev *dbidev;
+	int ret;
+	int i;
+	u32 rotation = 0;
+	struct resource res;
+	char str[32];
+
+	pdata = devm_kzalloc(dev, sizeof(struct ili9488_data), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	dbidev = devm_drm_dev_alloc(dev, &ili9488_driver,
+			struct mipi_dbi_dev, drm);
+	if (IS_ERR(dbidev))
+		return PTR_ERR(dbidev);
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dbi->dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dbi->dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dbi->dc);
+	}
+
+	pdata->wr = devm_gpiod_get(dev, "wr", GPIOD_OUT_HIGH);
+	if (IS_ERR(pdata->wr)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'wr'\n");
+		return PTR_ERR(pdata->wr);
+	}
+
+	pdata->cs = devm_gpiod_get(dev, "cs", GPIOD_OUT_LOW);
+	if (IS_ERR(pdata->cs)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'cs'\n");
+		return PTR_ERR(pdata->cs);
+	}
+
+	for (i = 0; i < 8; i++) {
+		struct gpio_desc *desc;
+		int gpio = of_get_named_gpio(np, "db-gpios", i);
+		if (gpio < 0)
+			break;	/* FIXME */
+
+		desc = gpio_to_desc(gpio);
+
+		devm_gpio_request(dev, gpio, NULL);
+		gpiod_direction_output(desc, 1);
+
+		pdata->db[i] = desc;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (!ret) {
+		pdata->membase = devm_ioremap(dev, res.start,
+				resource_size(&res));
+		if (!IS_ERR(pdata->membase)) {
+			for (i = 0; i < 8; i++) {
+				sprintf(str, "db-bits-%d", i);
+				ret = of_property_read_u32(np, str,
+						&pdata->bits[i]);
+				if (ret)
+					continue;
+				pdata->mask |= pdata->bits[i];
+			}
+
+			ret = of_property_read_u32(np, "db-bits-wr",
+					&pdata->bits_wr);
+			if (!ret)
+				pdata->mask |= pdata->bits_wr;
+		}
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	rgb = devm_kzalloc(dev, sizeof(u32) * 256, GFP_KERNEL);
+	if (rgb) {
+		u32 *p = rgb;
+		for (i = 0; i < 256; i++)
+			*p++ = ili9488_rgb565_to_gpiobus(pdata, i);
+	}
+
+	gpiod_set_value(pdata->wr, 1);
+	gpiod_set_value(dbi->dc, 0);
+
+	/* override the command function set in  mipi_dbi_spi_init() */
+	dbi->command = ili9488_command;
+	dbi->read_commands = NULL;
+	dbi->swap_bytes = true;
+
+	ret = mipi_dbi_dev_init(dbidev, &ili9488_pipe_funcs,
+			&ili9488_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, pdata);
+	pdata->dbidev = dbidev;
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int ili9488_remove(struct platform_device *pdev)
+{
+	struct ili9488_data *pdata = platform_get_drvdata(pdev);
+	struct mipi_dbi_dev *dbidev = pdata->dbidev;
+	struct drm_device *drm = &dbidev->drm;
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static const struct of_device_id ili9488_dt_ids[] = {
+	{ .compatible = "ili9488", 0 },
+	{ .compatible = "hardkernel,ili9488", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, ili9488_dt_ids);
+
+static struct platform_driver ili9488_platform_driver = {
+	.driver = {
+		.name = "ili9488",
+		.of_match_table = ili9488_dt_ids,
+	},
+	.probe = ili9488_probe,
+	.remove = ili9488_remove,
+};
+
+static int __init ili9488_init(void)
+{
+	return platform_driver_register(&ili9488_platform_driver);
+}
+
+static void __exit ili9488_exit(void)
+{
+	platform_driver_unregister(&ili9488_platform_driver);
+}
+
+module_init(ili9488_init);
+module_exit(ili9488_exit);
+
+MODULE_DESCRIPTION("Ilitek ILI9488 DRM driver (8bit PIO mode)");
+MODULE_AUTHOR("Dongjin Kim <tobetter@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c
index 0ba817e86346..fbb19a496e42 100644
--- a/drivers/iommu/io-pgtable-arm.c
+++ b/drivers/iommu/io-pgtable-arm.c
@@ -444,9 +444,10 @@ static arm_lpae_iopte arm_lpae_prot_to_pte(struct arm_lpae_io_pgtable *data,
 	 * "outside the GPU" (i.e. either the Inner or System domain in CPU
 	 * terms, depending on coherency).
 	 */
-	if (prot & IOMMU_CACHE && data->iop.fmt != ARM_MALI_LPAE)
+	if (prot & IOMMU_CACHE ||
+	    (data->iop.fmt == ARM_MALI_LPAE && !data->iop.cfg.coherent_walk))
 		pte |= ARM_LPAE_PTE_SH_IS;
-	else
+	else if (data->iop.fmt == ARM_MALI_LPAE)
 		pte |= ARM_LPAE_PTE_SH_OS;
 
 	if (prot & IOMMU_NOEXEC)
diff --git a/drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c b/drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c
index fca5c6405eec..115dff4b6f6f 100644
--- a/drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c
+++ b/drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c
@@ -861,6 +861,7 @@ static int s5p_mfc_open(struct file *file)
 	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	q->allow_cache_hints = 1;
 	ret = vb2_queue_init(q);
 	if (ret) {
 		mfc_err("Failed to initialize videobuf2 queue(capture)\n");
@@ -896,6 +897,7 @@ static int s5p_mfc_open(struct file *file)
 	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	q->allow_cache_hints = 1;
 	ret = vb2_queue_init(q);
 	if (ret) {
 		mfc_err("Failed to initialize videobuf2 queue(output)\n");
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index f453b0d09366..1a7999d2c2f8 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -771,6 +771,8 @@ static int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 	priv->wolopts = wol->wolopts;
 	mutex_unlock(&priv->lock);
 
+	phy_ethtool_set_wol(dev->phydev, wol);
+
 	return 0;
 }
 
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 3d99fd6664d7..fbb0998eaff6 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -12,6 +12,7 @@
 #include <linux/phy.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <linux/etherdevice.h>
 
 #define RTL821x_PHYSR				0x11
 #define RTL821x_PHYSR_DUPLEX			BIT(13)
@@ -234,7 +235,11 @@ static int rtl8211f_config_intr(struct phy_device *phydev)
 
 		val = RTL8211F_INER_LINK_STATUS;
 		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
+
+		phy_modify_paged(phydev, 0xd40, 0x16, BIT(5), 0);
 	} else {
+		phy_modify_paged(phydev, 0xd40, 0x16, 0, BIT(5));
+
 		val = 0;
 		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
 		if (err)
@@ -335,6 +340,34 @@ static int rtl8211c_config_init(struct phy_device *phydev)
 			    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);
 }
 
+static int rtl8211f_set_wol(struct phy_device *phydev,
+		struct ethtool_wolinfo *wol)
+{
+	struct net_device *netdev = phydev->attached_dev;
+	const u8 *mac = (const u8 *)netdev->dev_addr;
+
+	if ((wol->wolopts & (WAKE_MAGIC | WAKE_UCAST)) == 0) {
+		disable_irq_wake(phydev->irq);
+		return 0;
+	}
+
+	if ((wol->wolopts & WAKE_UCAST)
+			&& is_valid_ether_addr(mac)) {
+		phy_write_paged(phydev, 0xd8c, 0x10, (mac[1] << 8) | mac[0]);
+		phy_write_paged(phydev, 0xd8c, 0x11, (mac[3] << 8) | mac[2]);
+		phy_write_paged(phydev, 0xd8c, 0x12, (mac[5] << 8) | mac[4]);
+	}
+
+	if (wol->wolopts & WAKE_MAGIC) {
+		phy_write_paged(phydev, 0xd8a, 0x10, 0x1000);
+		phy_write_paged(phydev, 0xd8a, 0x11, 0x9fff);
+	}
+
+	enable_irq_wake(phydev->irq);
+
+	return 0;
+}
+
 static int rtl8211f_config_init(struct phy_device *phydev)
 {
 	struct rtl821x_priv *priv = phydev->priv;
@@ -929,6 +962,7 @@ static struct phy_driver realtek_drvs[] = {
 		.handle_interrupt = rtl8211f_handle_interrupt,
 		.suspend	= genphy_suspend,
 		.resume		= rtl821x_resume,
+		.set_wol	= rtl8211f_set_wol,
 		.read_page	= rtl821x_read_page,
 		.write_page	= rtl821x_write_page,
 	}, {
diff --git a/drivers/soc/samsung/pm_domains.c b/drivers/soc/samsung/pm_domains.c
index d07f3c9d6903..1022d40eb700 100644
--- a/drivers/soc/samsung/pm_domains.c
+++ b/drivers/soc/samsung/pm_domains.c
@@ -16,7 +16,7 @@
 #include <linux/delay.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
-#include <linux/pm_runtime.h>
+#include <linux/sched.h>
 
 struct exynos_pm_domain_config {
 	/* Value for LOCAL_PWR_CFG and STATUS fields for each domain */
@@ -72,15 +72,15 @@ static int exynos_pd_power_off(struct generic_pm_domain *domain)
 	return exynos_pd_power(domain, false);
 }
 
-static const struct exynos_pm_domain_config exynos4210_cfg = {
+static const struct exynos_pm_domain_config exynos4210_cfg __initconst = {
 	.local_pwr_cfg		= 0x7,
 };
 
-static const struct exynos_pm_domain_config exynos5433_cfg = {
+static const struct exynos_pm_domain_config exynos5433_cfg __initconst = {
 	.local_pwr_cfg		= 0xf,
 };
 
-static const struct of_device_id exynos_pm_domain_of_match[] = {
+static const struct of_device_id exynos_pm_domain_of_match[] __initconst = {
 	{
 		.compatible = "samsung,exynos4210-pd",
 		.data = &exynos4210_cfg,
@@ -91,7 +91,7 @@ static const struct of_device_id exynos_pm_domain_of_match[] = {
 	{ },
 };
 
-static const char *exynos_get_domain_name(struct device_node *node)
+static __init const char *exynos_get_domain_name(struct device_node *node)
 {
 	const char *name;
 
@@ -100,44 +100,60 @@ static const char *exynos_get_domain_name(struct device_node *node)
 	return kstrdup_const(name, GFP_KERNEL);
 }
 
-static int exynos_pd_probe(struct platform_device *pdev)
+static __init int exynos4_pm_init_power_domain(void)
 {
-	const struct exynos_pm_domain_config *pm_domain_cfg;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	struct of_phandle_args child, parent;
-	struct exynos_pm_domain *pd;
-	int on, ret;
+	struct device_node *np;
+	const struct of_device_id *match;
 
-	pm_domain_cfg = of_device_get_match_data(dev);
-	pd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);
-	if (!pd)
-		return -ENOMEM;
+	for_each_matching_node_and_match(np, exynos_pm_domain_of_match, &match) {
+		const struct exynos_pm_domain_config *pm_domain_cfg;
+		struct exynos_pm_domain *pd;
+		int on;
 
-	pd->pd.name = exynos_get_domain_name(np);
-	if (!pd->pd.name)
-		return -ENOMEM;
+		pm_domain_cfg = match->data;
 
-	pd->base = of_iomap(np, 0);
-	if (!pd->base) {
-		kfree_const(pd->pd.name);
-		return -ENODEV;
-	}
+		pd = kzalloc(sizeof(*pd), GFP_KERNEL);
+		if (!pd) {
+			of_node_put(np);
+			return -ENOMEM;
+		}
+		pd->pd.name = exynos_get_domain_name(np);
+		if (!pd->pd.name) {
+			kfree(pd);
+			of_node_put(np);
+			return -ENOMEM;
+		}
 
-	pd->pd.power_off = exynos_pd_power_off;
-	pd->pd.power_on = exynos_pd_power_on;
-	pd->local_pwr_cfg = pm_domain_cfg->local_pwr_cfg;
+		pd->base = of_iomap(np, 0);
+		if (!pd->base) {
+			pr_warn("%s: failed to map memory\n", __func__);
+			kfree_const(pd->pd.name);
+			kfree(pd);
+			continue;
+		}
+
+		pd->pd.power_off = exynos_pd_power_off;
+		pd->pd.power_on = exynos_pd_power_on;
+		pd->local_pwr_cfg = pm_domain_cfg->local_pwr_cfg;
 
-	on = readl_relaxed(pd->base + 0x4) & pd->local_pwr_cfg;
+		on = readl_relaxed(pd->base + 0x4) & pd->local_pwr_cfg;
+
+		pm_genpd_init(&pd->pd, NULL, !on);
+		of_genpd_add_provider_simple(np, &pd->pd);
+	}
 
-	pm_genpd_init(&pd->pd, NULL, !on);
-	ret = of_genpd_add_provider_simple(np, &pd->pd);
+	/* Assign the child power domains to their parents */
+	for_each_matching_node(np, exynos_pm_domain_of_match) {
+		struct of_phandle_args child, parent;
 
-	if (ret == 0 && of_parse_phandle_with_args(np, "power-domains",
-				      "#power-domain-cells", 0, &parent) == 0) {
 		child.np = np;
 		child.args_count = 0;
 
+		if (of_parse_phandle_with_args(np, "power-domains",
+					       "#power-domain-cells", 0,
+					       &parent) != 0)
+			continue;
+
 		if (of_genpd_add_subdomain(&parent, &child))
 			pr_warn("%pOF failed to add subdomain: %pOF\n",
 				parent.np, child.np);
@@ -146,21 +162,6 @@ static int exynos_pd_probe(struct platform_device *pdev)
 				parent.np, child.np);
 	}
 
-	pm_runtime_enable(dev);
-	return ret;
-}
-
-static struct platform_driver exynos_pd_driver = {
-	.probe	= exynos_pd_probe,
-	.driver	= {
-		.name		= "exynos-pd",
-		.of_match_table	= exynos_pm_domain_of_match,
-		.suppress_bind_attrs = true,
-	}
-};
-
-static __init int exynos4_pm_init_power_domain(void)
-{
-	return platform_driver_register(&exynos_pd_driver);
+	return 0;
 }
 core_initcall(exynos4_pm_init_power_domain);
diff --git a/include/drm/drm_mipi_dbi.h b/include/drm/drm_mipi_dbi.h
index 14eaecb1825c..3b46954cd47b 100644
--- a/include/drm/drm_mipi_dbi.h
+++ b/include/drm/drm_mipi_dbi.h
@@ -193,12 +193,7 @@ int mipi_dbi_buf_copy(void *dst, struct drm_framebuffer *fb,
 #define mipi_dbi_command(dbi, cmd, seq...) \
 ({ \
 	const u8 d[] = { seq }; \
-	struct device *dev = &(dbi)->spi->dev;	\
-	int ret; \
-	ret = mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
-	if (ret) \
-		dev_err_ratelimited(dev, "error %d when sending command %#02x\n", ret, cmd); \
-	ret; \
+	mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
 })
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 3aa384cec76b..b9f35e9700d4 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -334,7 +334,7 @@ quiet_cmd_gzip = GZIP    $@
 # DTC
 # ---------------------------------------------------------------------------
 DTC ?= $(objtree)/scripts/dtc/dtc
-DTC_FLAGS += -Wno-interrupt_provider
+DTC_FLAGS += -Wno-interrupt_provider --symbol
 
 # Disable noisy checks by default
 ifeq ($(findstring 1,$(KBUILD_EXTRA_WARN)),)
diff --git a/sound/soc/samsung/snow.c b/sound/soc/samsung/snow.c
index da342da03880..92d3d299d635 100644
--- a/sound/soc/samsung/snow.c
+++ b/sound/soc/samsung/snow.c
@@ -3,10 +3,12 @@
 // ASoC machine driver for Snow boards
 
 #include <linux/clk.h>
+#include <linux/gpio/consumer.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <sound/jack.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 
@@ -22,6 +24,37 @@ SND_SOC_DAILINK_DEFS(links,
 struct snow_priv {
 	struct snd_soc_dai_link dai_link;
 	struct clk *clk_i2s_bus;
+	struct gpio_desc *gpiod_hp_det;
+	struct gpio_desc *gpiod_mic_det;
+};
+
+static struct snd_soc_jack snow_hp_jack;
+
+static struct snd_soc_jack_pin snow_hp_jack_pins[] = {
+	{ .pin = "Headphone Jack", .mask = SND_JACK_HEADPHONE },
+};
+
+static struct snd_soc_jack_gpio snow_hp_jack_gpio = {
+	.name = "Headphones detection",
+	.report = SND_JACK_HEADPHONE,
+	.debounce_time = 150,
+};
+
+static struct snd_soc_jack snow_mic_jack;
+
+static struct snd_soc_jack_pin snow_mic_jack_pins[] = {
+	{ .pin = "Mic Jack", .mask = SND_JACK_MICROPHONE },
+};
+
+static struct snd_soc_jack_gpio snow_mic_jack_gpio = {
+	.name = "Microphone detection",
+	.report = SND_JACK_MICROPHONE,
+	.debounce_time = 150,
+};
+
+static const struct snd_soc_dapm_widget snow_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
 };
 
 static int snow_card_hw_params(struct snd_pcm_substream *substream,
@@ -105,9 +138,56 @@ static int snow_late_probe(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai *codec_dai;
+	struct snow_priv *priv = snd_soc_card_get_drvdata(card);
+	const char *jack_name;
+	int err;
 
 	rtd = snd_soc_get_pcm_runtime(card, &card->dai_link[0]);
 
+	if (priv->gpiod_hp_det) {
+		jack_name = "Headphones";
+
+		err = snd_soc_card_jack_new_pins(card, jack_name,
+					    SND_JACK_HEADPHONE,
+					    &snow_hp_jack,
+					    snow_hp_jack_pins,
+					    ARRAY_SIZE(snow_hp_jack_pins));
+		if (err) {
+			dev_err(rtd->dev,
+				"Headphones Jack creation failed: %d\n", err);
+			return err;
+		}
+
+		snow_hp_jack_gpio.desc = priv->gpiod_hp_det;
+
+		err = snd_soc_jack_add_gpios(&snow_hp_jack, 1,
+					     &snow_hp_jack_gpio);
+		if (err)
+			dev_err(rtd->dev, "Headphones GPIOs not added: %d\n", err);
+	}
+
+	if (priv->gpiod_mic_det) {
+		jack_name = "Microphone";
+
+		err = snd_soc_card_jack_new_pins(card, jack_name,
+					    SND_JACK_MICROPHONE,
+					    &snow_mic_jack,
+					    snow_mic_jack_pins,
+					    ARRAY_SIZE(snow_mic_jack_pins));
+		if (err) {
+			dev_err(rtd->dev,
+				"Microphone Jack creation failed: %d\n", err);
+			return err;
+		}
+
+		snow_mic_jack_gpio.desc = priv->gpiod_mic_det;
+
+		err = snd_soc_jack_add_gpios(&snow_mic_jack, 1,
+					     &snow_mic_jack_gpio);
+		if (err)
+			dev_err(rtd->dev, "Microphone GPIOs not added: %d\n", err);
+	}
+
 	/* In the multi-codec case codec_dais 0 is MAX98095 and 1 is HDMI. */
 	codec_dai = asoc_rtd_to_codec(rtd, 0);
 
@@ -129,6 +209,7 @@ static int snow_probe(struct platform_device *pdev)
 	struct device_node *cpu, *codec;
 	struct snd_soc_dai_link *link;
 	struct snow_priv *priv;
+	struct gpio_desc *gpiod;
 	int ret;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
@@ -137,6 +218,16 @@ static int snow_probe(struct platform_device *pdev)
 
 	link = &priv->dai_link;
 
+	gpiod = devm_gpiod_get_optional(dev, "samsung,hp-det", GPIOD_IN);
+	priv->gpiod_hp_det = gpiod;
+	if (IS_ERR(gpiod))
+		return PTR_ERR(gpiod);
+
+	gpiod = devm_gpiod_get_optional(dev, "samsung,mic-det", GPIOD_IN);
+	priv->gpiod_mic_det = gpiod;
+	if (IS_ERR(gpiod))
+		return PTR_ERR(gpiod);
+
 	link->dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
 			SND_SOC_DAIFMT_CBS_CFS;
 
@@ -154,6 +245,9 @@ static int snow_probe(struct platform_device *pdev)
 	card->num_links = 1;
 	card->dev = dev;
 
+	card->dapm_widgets = snow_dapm_widgets;
+	card->num_dapm_widgets = ARRAY_SIZE(snow_dapm_widgets);
+
 	/* Try new DT bindings with HDMI support first. */
 	cpu = of_get_child_by_name(dev->of_node, "cpu");
 
